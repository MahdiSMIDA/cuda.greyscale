#include <iostream>#include <png++/png.hpp>#include <cmath>typedef struct pixel {    png::byte red;    png::byte blue;    png::byte green;    void from_rgb_pixel(png::rgb_pixel other) {        this->red = other.red;        this->blue = other.blue;        this->green = other.green;    }    auto to_rgb_pixel() -> png::rgb_pixel const {        return png::rgb_pixel(this->red, this->blue, this->green);    }} pixel;__global__void image_to_greyscale(pixel *pixels, pixel *result, size_t size) {    for (size_t index = 0; index < size; index++) {        pixel pixel = pixels[index];        auto value = (png::byte) (sqrtf(                pixel.red * pixel.red +                pixel.blue * pixel.blue +                pixel.green * pixel.green) / 3);        result[index] = {value, value, value};    }}int main() {    png::image<png::rgb_pixel> original("original_image.png");    pixel *pixels;    pixel *result;    cudaMallocManaged(&pixels, original.get_width() *                               original.get_height() * sizeof(pixel));    cudaMallocManaged(&result, original.get_width() *                               original.get_height() * sizeof(pixel));    size_t width = original.get_width();    size_t height = original.get_height();    for(size_t row = 0; row < height; row++)        for(size_t column = 0; column < width; column++)            pixels[row * width + column].from_rgb_pixel(                    original.get_pixel(row, column));    image_to_greyscale<<<1, 1>>>(pixels, result, width * height);    cudaDeviceSynchronize();    for(size_t row = 0; row < height; row++)        for(size_t column = 0; column < width; column++)            original.set_pixel(row, column, result[row * width + column]                    .to_rgb_pixel());    original.write("greyscale.png");    cudaFree(pixels);    cudaFree(result);    return 0;}